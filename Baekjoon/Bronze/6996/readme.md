# [6996] 애너그램

## 문제 설명

두 단어가 주어졌을 때, 한 단어의 알파벳 순서를 바꿔 다른 단어를 만들 수 있는지(애너그램인지) 판단하는 문제

## 배열이 동일한지 알아보는 방법

### 참조 비교

두 배열이 동일한 메모리 참조를 공유하는 지 확인

```js
const arr1 = [1, 2, 3];
const arr2 = arr1; // arr2는 arr1과 동일한 참조를 가짐

console.log(arr1 === arr2); // true (같은 참조)
```

### 값 비교

배열 요소의 값과 순서가 동일한지 확인

1.  **JSON 문자열 비교**  
    JSON.stringify(arr)를 통해 배열을 JSON 문자열로 변환하여 비교

2.  **배열의 길이와 요소 비교**  
    배열의 길이와 각 요소를 순회하며 비교
3.  **Lodash 라이브러리 사용**  
    Lodash의 isEqual 함수를 사용

    ```js
    const _ = require("lodash");

    const arr1 = [1, 2, [3, 4]];
    const arr2 = [1, 2, [3, 4]];
    const arr3 = [1, 2, [4, 3]];

    console.log(_.isEqual(arr1, arr2)); // true
    console.log(_.isEqual(arr1, arr3)); // false
    ```

### 얕은 비교 vs 깊은 비교

기준 : 데이터의 중첩 구조를 얼마나 확인

**얕은 비교 (Shallow Comparison) :**

- 데이터의 최상위 레벨만 비교 (참조값)
- 중첩된 객체나 배열의 내부 값은 확인하지 않습니다.

**깊은 비교 (Deep Comparison) :**

- 중첩된 객체나 배열의 모든 레벨을 비교하여 데이터가 완전히 동일한지 확인

---

이 개념은 주로 **참조 타입의 비교에서 사용하는 개념**입니다.

**원시 타입 (Primitive Type)**

- 숫자, 문자열, 불리언, null, undefined, symbol, bigint 등
- 원시 타입은 값 자체를 저장하며, 중첩 구조가 없다는 특징
- 비교 연산자(===, ==)를 사용하면 값을 직접 비교

**참조 타입 (Reference Type)**

- 객체, 배열, 함수 등
- 참조 타입은 **값이 아닌 메모리 주소(참조값)** 를 저장
- 비교 연산자(===, ==)는 **메모리 주소(참조값)** 를 비교
